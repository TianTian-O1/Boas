/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_BOASMATRIXANALYSISPASS
#define GEN_PASS_DECL_BOASMATRIXOPTIMIZATIONPASS
#define GEN_PASS_DECL_BOASNPUOPTIMIZATIONPASS
#define GEN_PASS_DECL_BOASTOLINALGLOWERINGPASS
#define GEN_PASS_DECL_BOASTOSTANDARDLOWERINGPASS
#define GEN_PASS_DECL_DEVICEAWAREOPTIMIZATIONPASS
#define GEN_PASS_DECL_NPUKERNELGENERATIONPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// BoasMatrixAnalysisPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BOASMATRIXANALYSISPASS
struct BoasMatrixAnalysisPassOptions {
  bool verboseOutput = false;
  std::string outputFile = "";
};
#undef GEN_PASS_DECL_BOASMATRIXANALYSISPASS
#endif // GEN_PASS_DECL_BOASMATRIXANALYSISPASS
#ifdef GEN_PASS_DEF_BOASMATRIXANALYSISPASS
namespace impl {

template <typename DerivedT>
class BoasMatrixAnalysisPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BoasMatrixAnalysisPassBase;

  BoasMatrixAnalysisPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BoasMatrixAnalysisPassBase(const BoasMatrixAnalysisPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  BoasMatrixAnalysisPassBase& operator=(const BoasMatrixAnalysisPassBase &) = delete;
  BoasMatrixAnalysisPassBase(BoasMatrixAnalysisPassBase &&) = delete;
  BoasMatrixAnalysisPassBase& operator=(BoasMatrixAnalysisPassBase &&) = delete;
  ~BoasMatrixAnalysisPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("boas-matrix-analysis");
  }
  ::llvm::StringRef getArgument() const override { return "boas-matrix-analysis"; }

  ::llvm::StringRef getDescription() const override { return "Analyze Boas matrix operations for optimization opportunities"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BoasMatrixAnalysisPass");
  }
  ::llvm::StringRef getName() const override { return "BoasMatrixAnalysisPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BoasMatrixAnalysisPassBase<DerivedT>)

  BoasMatrixAnalysisPassBase(BoasMatrixAnalysisPassOptions options) : BoasMatrixAnalysisPassBase() {
    verboseOutput = std::move(options.verboseOutput);
    outputFile = std::move(options.outputFile);
  }
protected:
  ::mlir::Pass::Option<bool> verboseOutput{*this, "verbose", ::llvm::cl::desc("Enable verbose analysis output"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<std::string> outputFile{*this, "output-file", ::llvm::cl::desc("Output file for analysis results"), ::llvm::cl::init("")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BOASMATRIXANALYSISPASS
#endif // GEN_PASS_DEF_BOASMATRIXANALYSISPASS

//===----------------------------------------------------------------------===//
// BoasMatrixOptimizationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BOASMATRIXOPTIMIZATIONPASS
struct BoasMatrixOptimizationPassOptions {
  bool enableFusion = true;
  int64_t tileSize = 128;
};
#undef GEN_PASS_DECL_BOASMATRIXOPTIMIZATIONPASS
#endif // GEN_PASS_DECL_BOASMATRIXOPTIMIZATIONPASS
#ifdef GEN_PASS_DEF_BOASMATRIXOPTIMIZATIONPASS
namespace impl {

template <typename DerivedT>
class BoasMatrixOptimizationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BoasMatrixOptimizationPassBase;

  BoasMatrixOptimizationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BoasMatrixOptimizationPassBase(const BoasMatrixOptimizationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  BoasMatrixOptimizationPassBase& operator=(const BoasMatrixOptimizationPassBase &) = delete;
  BoasMatrixOptimizationPassBase(BoasMatrixOptimizationPassBase &&) = delete;
  BoasMatrixOptimizationPassBase& operator=(BoasMatrixOptimizationPassBase &&) = delete;
  ~BoasMatrixOptimizationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("boas-matrix-opt");
  }
  ::llvm::StringRef getArgument() const override { return "boas-matrix-opt"; }

  ::llvm::StringRef getDescription() const override { return "Optimize Boas matrix operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BoasMatrixOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "BoasMatrixOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BoasMatrixOptimizationPassBase<DerivedT>)

  BoasMatrixOptimizationPassBase(BoasMatrixOptimizationPassOptions options) : BoasMatrixOptimizationPassBase() {
    enableFusion = std::move(options.enableFusion);
    tileSize = std::move(options.tileSize);
  }
protected:
  ::mlir::Pass::Option<bool> enableFusion{*this, "enable-fusion", ::llvm::cl::desc("Enable matrix operation fusion"), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<int64_t> tileSize{*this, "tile-size", ::llvm::cl::desc("Tile size for matrix operations"), ::llvm::cl::init(128)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BOASMATRIXOPTIMIZATIONPASS
#endif // GEN_PASS_DEF_BOASMATRIXOPTIMIZATIONPASS

//===----------------------------------------------------------------------===//
// BoasNPUOptimizationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BOASNPUOPTIMIZATIONPASS
struct BoasNPUOptimizationPassOptions {
  std::string targetDevice = "npu";
  bool enableDiagonalTiling = true;
  int64_t blockSizeM = 128;
  int64_t blockSizeN = 256;
  int64_t blockSizeK = 256;
};
#undef GEN_PASS_DECL_BOASNPUOPTIMIZATIONPASS
#endif // GEN_PASS_DECL_BOASNPUOPTIMIZATIONPASS
#ifdef GEN_PASS_DEF_BOASNPUOPTIMIZATIONPASS
namespace impl {

template <typename DerivedT>
class BoasNPUOptimizationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BoasNPUOptimizationPassBase;

  BoasNPUOptimizationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BoasNPUOptimizationPassBase(const BoasNPUOptimizationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  BoasNPUOptimizationPassBase& operator=(const BoasNPUOptimizationPassBase &) = delete;
  BoasNPUOptimizationPassBase(BoasNPUOptimizationPassBase &&) = delete;
  BoasNPUOptimizationPassBase& operator=(BoasNPUOptimizationPassBase &&) = delete;
  ~BoasNPUOptimizationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("boas-npu-opt");
  }
  ::llvm::StringRef getArgument() const override { return "boas-npu-opt"; }

  ::llvm::StringRef getDescription() const override { return "NPU-specific optimizations for Boas operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BoasNPUOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "BoasNPUOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BoasNPUOptimizationPassBase<DerivedT>)

  BoasNPUOptimizationPassBase(BoasNPUOptimizationPassOptions options) : BoasNPUOptimizationPassBase() {
    targetDevice = std::move(options.targetDevice);
    enableDiagonalTiling = std::move(options.enableDiagonalTiling);
    blockSizeM = std::move(options.blockSizeM);
    blockSizeN = std::move(options.blockSizeN);
    blockSizeK = std::move(options.blockSizeK);
  }
protected:
  ::mlir::Pass::Option<std::string> targetDevice{*this, "target-device", ::llvm::cl::desc("Target device for optimization"), ::llvm::cl::init("npu")};
  ::mlir::Pass::Option<bool> enableDiagonalTiling{*this, "enable-diagonal-tiling", ::llvm::cl::desc("Enable diagonal tiling optimization"), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<int64_t> blockSizeM{*this, "block-m", ::llvm::cl::desc("Block size for M dimension"), ::llvm::cl::init(128)};
  ::mlir::Pass::Option<int64_t> blockSizeN{*this, "block-n", ::llvm::cl::desc("Block size for N dimension"), ::llvm::cl::init(256)};
  ::mlir::Pass::Option<int64_t> blockSizeK{*this, "block-k", ::llvm::cl::desc("Block size for K dimension"), ::llvm::cl::init(256)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BOASNPUOPTIMIZATIONPASS
#endif // GEN_PASS_DEF_BOASNPUOPTIMIZATIONPASS

//===----------------------------------------------------------------------===//
// BoasToLinalgLoweringPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BOASTOLINALGLOWERINGPASS
#undef GEN_PASS_DECL_BOASTOLINALGLOWERINGPASS
#endif // GEN_PASS_DECL_BOASTOLINALGLOWERINGPASS
#ifdef GEN_PASS_DEF_BOASTOLINALGLOWERINGPASS
namespace impl {

template <typename DerivedT>
class BoasToLinalgLoweringPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BoasToLinalgLoweringPassBase;

  BoasToLinalgLoweringPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BoasToLinalgLoweringPassBase(const BoasToLinalgLoweringPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  BoasToLinalgLoweringPassBase& operator=(const BoasToLinalgLoweringPassBase &) = delete;
  BoasToLinalgLoweringPassBase(BoasToLinalgLoweringPassBase &&) = delete;
  BoasToLinalgLoweringPassBase& operator=(BoasToLinalgLoweringPassBase &&) = delete;
  ~BoasToLinalgLoweringPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("boas-to-linalg");
  }
  ::llvm::StringRef getArgument() const override { return "boas-to-linalg"; }

  ::llvm::StringRef getDescription() const override { return "Lower Boas matrix operations to Linalg"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BoasToLinalgLoweringPass");
  }
  ::llvm::StringRef getName() const override { return "BoasToLinalgLoweringPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<linalg::LinalgDialect>();
    registry.insert<tensor::TensorDialect>();
    registry.insert<arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BoasToLinalgLoweringPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BOASTOLINALGLOWERINGPASS
#endif // GEN_PASS_DEF_BOASTOLINALGLOWERINGPASS

//===----------------------------------------------------------------------===//
// BoasToStandardLoweringPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BOASTOSTANDARDLOWERINGPASS
#undef GEN_PASS_DECL_BOASTOSTANDARDLOWERINGPASS
#endif // GEN_PASS_DECL_BOASTOSTANDARDLOWERINGPASS
#ifdef GEN_PASS_DEF_BOASTOSTANDARDLOWERINGPASS
namespace impl {

template <typename DerivedT>
class BoasToStandardLoweringPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BoasToStandardLoweringPassBase;

  BoasToStandardLoweringPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BoasToStandardLoweringPassBase(const BoasToStandardLoweringPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  BoasToStandardLoweringPassBase& operator=(const BoasToStandardLoweringPassBase &) = delete;
  BoasToStandardLoweringPassBase(BoasToStandardLoweringPassBase &&) = delete;
  BoasToStandardLoweringPassBase& operator=(BoasToStandardLoweringPassBase &&) = delete;
  ~BoasToStandardLoweringPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("boas-to-standard");
  }
  ::llvm::StringRef getArgument() const override { return "boas-to-standard"; }

  ::llvm::StringRef getDescription() const override { return "Lower Boas dialect to standard dialects"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BoasToStandardLoweringPass");
  }
  ::llvm::StringRef getName() const override { return "BoasToStandardLoweringPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BoasToStandardLoweringPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BOASTOSTANDARDLOWERINGPASS
#endif // GEN_PASS_DEF_BOASTOSTANDARDLOWERINGPASS

//===----------------------------------------------------------------------===//
// DeviceAwareOptimizationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DEVICEAWAREOPTIMIZATIONPASS
struct DeviceAwareOptimizationPassOptions {
  ::llvm::SmallVector<std::string> availableDevices;
  bool enableAutoPlacement = true;
};
#undef GEN_PASS_DECL_DEVICEAWAREOPTIMIZATIONPASS
#endif // GEN_PASS_DECL_DEVICEAWAREOPTIMIZATIONPASS
#ifdef GEN_PASS_DEF_DEVICEAWAREOPTIMIZATIONPASS
namespace impl {

template <typename DerivedT>
class DeviceAwareOptimizationPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = DeviceAwareOptimizationPassBase;

  DeviceAwareOptimizationPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  DeviceAwareOptimizationPassBase(const DeviceAwareOptimizationPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  DeviceAwareOptimizationPassBase& operator=(const DeviceAwareOptimizationPassBase &) = delete;
  DeviceAwareOptimizationPassBase(DeviceAwareOptimizationPassBase &&) = delete;
  DeviceAwareOptimizationPassBase& operator=(DeviceAwareOptimizationPassBase &&) = delete;
  ~DeviceAwareOptimizationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("boas-device-opt");
  }
  ::llvm::StringRef getArgument() const override { return "boas-device-opt"; }

  ::llvm::StringRef getDescription() const override { return "Device-aware optimization for Boas operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DeviceAwareOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "DeviceAwareOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DeviceAwareOptimizationPassBase<DerivedT>)

  DeviceAwareOptimizationPassBase(DeviceAwareOptimizationPassOptions options) : DeviceAwareOptimizationPassBase() {
    availableDevices = std::move(options.availableDevices);
    enableAutoPlacement = std::move(options.enableAutoPlacement);
  }
protected:
  ::mlir::Pass::ListOption<std::string> availableDevices{*this, "available-devices", ::llvm::cl::desc("List of available devices"), llvm::cl::MiscFlags::CommaSeparated};
  ::mlir::Pass::Option<bool> enableAutoPlacement{*this, "enable-auto-placement", ::llvm::cl::desc("Enable automatic device placement"), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DEVICEAWAREOPTIMIZATIONPASS
#endif // GEN_PASS_DEF_DEVICEAWAREOPTIMIZATIONPASS

//===----------------------------------------------------------------------===//
// NPUKernelGenerationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_NPUKERNELGENERATIONPASS
struct NPUKernelGenerationPassOptions {
  std::string kernelNamePrefix = "boas_";
  bool generateDebugInfo = false;
  bool optimizeKernelLaunch = true;
};
#undef GEN_PASS_DECL_NPUKERNELGENERATIONPASS
#endif // GEN_PASS_DECL_NPUKERNELGENERATIONPASS
#ifdef GEN_PASS_DEF_NPUKERNELGENERATIONPASS
namespace impl {

template <typename DerivedT>
class NPUKernelGenerationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = NPUKernelGenerationPassBase;

  NPUKernelGenerationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  NPUKernelGenerationPassBase(const NPUKernelGenerationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  NPUKernelGenerationPassBase& operator=(const NPUKernelGenerationPassBase &) = delete;
  NPUKernelGenerationPassBase(NPUKernelGenerationPassBase &&) = delete;
  NPUKernelGenerationPassBase& operator=(NPUKernelGenerationPassBase &&) = delete;
  ~NPUKernelGenerationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("npu-kernel-gen");
  }
  ::llvm::StringRef getArgument() const override { return "npu-kernel-gen"; }

  ::llvm::StringRef getDescription() const override { return "Generate NPU kernels for Boas operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NPUKernelGenerationPass");
  }
  ::llvm::StringRef getName() const override { return "NPUKernelGenerationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NPUKernelGenerationPassBase<DerivedT>)

  NPUKernelGenerationPassBase(NPUKernelGenerationPassOptions options) : NPUKernelGenerationPassBase() {
    kernelNamePrefix = std::move(options.kernelNamePrefix);
    generateDebugInfo = std::move(options.generateDebugInfo);
    optimizeKernelLaunch = std::move(options.optimizeKernelLaunch);
  }
protected:
  ::mlir::Pass::Option<std::string> kernelNamePrefix{*this, "kernel-prefix", ::llvm::cl::desc("Prefix for generated kernel names"), ::llvm::cl::init("boas_")};
  ::mlir::Pass::Option<bool> generateDebugInfo{*this, "debug-info", ::llvm::cl::desc("Generate debug information for kernels"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> optimizeKernelLaunch{*this, "optimize-launch", ::llvm::cl::desc("Optimize kernel launch overhead"), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_NPUKERNELGENERATIONPASS
#endif // GEN_PASS_DEF_NPUKERNELGENERATIONPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// BoasMatrixAnalysisPass Registration
//===----------------------------------------------------------------------===//

inline void registerBoasMatrixAnalysisPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::boas::createBoasMatrixAnalysisPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBoasMatrixAnalysisPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::boas::createBoasMatrixAnalysisPass();
  });
}

//===----------------------------------------------------------------------===//
// BoasMatrixOptimizationPass Registration
//===----------------------------------------------------------------------===//

inline void registerBoasMatrixOptimizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::boas::createBoasMatrixOptimizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBoasMatrixOptimizationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::boas::createBoasMatrixOptimizationPass();
  });
}

//===----------------------------------------------------------------------===//
// BoasNPUOptimizationPass Registration
//===----------------------------------------------------------------------===//

inline void registerBoasNPUOptimizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::boas::createBoasNPUOptimizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBoasNPUOptimizationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::boas::createBoasNPUOptimizationPass();
  });
}

//===----------------------------------------------------------------------===//
// BoasToLinalgLoweringPass Registration
//===----------------------------------------------------------------------===//

inline void registerBoasToLinalgLoweringPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::boas::createBoasToLinalgLoweringPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBoasToLinalgLoweringPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::boas::createBoasToLinalgLoweringPass();
  });
}

//===----------------------------------------------------------------------===//
// BoasToStandardLoweringPass Registration
//===----------------------------------------------------------------------===//

inline void registerBoasToStandardLoweringPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::boas::createBoasToStandardLoweringPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBoasToStandardLoweringPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::boas::createBoasToStandardLoweringPass();
  });
}

//===----------------------------------------------------------------------===//
// DeviceAwareOptimizationPass Registration
//===----------------------------------------------------------------------===//

inline void registerDeviceAwareOptimizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::boas::createDeviceAwareOptimizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDeviceAwareOptimizationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::boas::createDeviceAwareOptimizationPass();
  });
}

//===----------------------------------------------------------------------===//
// NPUKernelGenerationPass Registration
//===----------------------------------------------------------------------===//

inline void registerNPUKernelGenerationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::boas::createNPUKernelGenerationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerNPUKernelGenerationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::boas::createNPUKernelGenerationPass();
  });
}

//===----------------------------------------------------------------------===//
//  Registration
//===----------------------------------------------------------------------===//

inline void registerPasses() {
  registerBoasMatrixAnalysisPass();
  registerBoasMatrixOptimizationPass();
  registerBoasNPUOptimizationPass();
  registerBoasToLinalgLoweringPass();
  registerBoasToStandardLoweringPass();
  registerDeviceAwareOptimizationPass();
  registerNPUKernelGenerationPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class BoasMatrixAnalysisPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BoasMatrixAnalysisPassBase;

  BoasMatrixAnalysisPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BoasMatrixAnalysisPassBase(const BoasMatrixAnalysisPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  BoasMatrixAnalysisPassBase& operator=(const BoasMatrixAnalysisPassBase &) = delete;
  BoasMatrixAnalysisPassBase(BoasMatrixAnalysisPassBase &&) = delete;
  BoasMatrixAnalysisPassBase& operator=(BoasMatrixAnalysisPassBase &&) = delete;
  ~BoasMatrixAnalysisPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("boas-matrix-analysis");
  }
  ::llvm::StringRef getArgument() const override { return "boas-matrix-analysis"; }

  ::llvm::StringRef getDescription() const override { return "Analyze Boas matrix operations for optimization opportunities"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BoasMatrixAnalysisPass");
  }
  ::llvm::StringRef getName() const override { return "BoasMatrixAnalysisPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BoasMatrixAnalysisPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> verboseOutput{*this, "verbose", ::llvm::cl::desc("Enable verbose analysis output"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<std::string> outputFile{*this, "output-file", ::llvm::cl::desc("Output file for analysis results"), ::llvm::cl::init("")};
};

template <typename DerivedT>
class BoasMatrixOptimizationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BoasMatrixOptimizationPassBase;

  BoasMatrixOptimizationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BoasMatrixOptimizationPassBase(const BoasMatrixOptimizationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  BoasMatrixOptimizationPassBase& operator=(const BoasMatrixOptimizationPassBase &) = delete;
  BoasMatrixOptimizationPassBase(BoasMatrixOptimizationPassBase &&) = delete;
  BoasMatrixOptimizationPassBase& operator=(BoasMatrixOptimizationPassBase &&) = delete;
  ~BoasMatrixOptimizationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("boas-matrix-opt");
  }
  ::llvm::StringRef getArgument() const override { return "boas-matrix-opt"; }

  ::llvm::StringRef getDescription() const override { return "Optimize Boas matrix operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BoasMatrixOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "BoasMatrixOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BoasMatrixOptimizationPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> enableFusion{*this, "enable-fusion", ::llvm::cl::desc("Enable matrix operation fusion"), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<int64_t> tileSize{*this, "tile-size", ::llvm::cl::desc("Tile size for matrix operations"), ::llvm::cl::init(128)};
};

template <typename DerivedT>
class BoasNPUOptimizationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BoasNPUOptimizationPassBase;

  BoasNPUOptimizationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BoasNPUOptimizationPassBase(const BoasNPUOptimizationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  BoasNPUOptimizationPassBase& operator=(const BoasNPUOptimizationPassBase &) = delete;
  BoasNPUOptimizationPassBase(BoasNPUOptimizationPassBase &&) = delete;
  BoasNPUOptimizationPassBase& operator=(BoasNPUOptimizationPassBase &&) = delete;
  ~BoasNPUOptimizationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("boas-npu-opt");
  }
  ::llvm::StringRef getArgument() const override { return "boas-npu-opt"; }

  ::llvm::StringRef getDescription() const override { return "NPU-specific optimizations for Boas operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BoasNPUOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "BoasNPUOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BoasNPUOptimizationPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> targetDevice{*this, "target-device", ::llvm::cl::desc("Target device for optimization"), ::llvm::cl::init("npu")};
  ::mlir::Pass::Option<bool> enableDiagonalTiling{*this, "enable-diagonal-tiling", ::llvm::cl::desc("Enable diagonal tiling optimization"), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<int64_t> blockSizeM{*this, "block-m", ::llvm::cl::desc("Block size for M dimension"), ::llvm::cl::init(128)};
  ::mlir::Pass::Option<int64_t> blockSizeN{*this, "block-n", ::llvm::cl::desc("Block size for N dimension"), ::llvm::cl::init(256)};
  ::mlir::Pass::Option<int64_t> blockSizeK{*this, "block-k", ::llvm::cl::desc("Block size for K dimension"), ::llvm::cl::init(256)};
};

template <typename DerivedT>
class BoasToLinalgLoweringPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BoasToLinalgLoweringPassBase;

  BoasToLinalgLoweringPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BoasToLinalgLoweringPassBase(const BoasToLinalgLoweringPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  BoasToLinalgLoweringPassBase& operator=(const BoasToLinalgLoweringPassBase &) = delete;
  BoasToLinalgLoweringPassBase(BoasToLinalgLoweringPassBase &&) = delete;
  BoasToLinalgLoweringPassBase& operator=(BoasToLinalgLoweringPassBase &&) = delete;
  ~BoasToLinalgLoweringPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("boas-to-linalg");
  }
  ::llvm::StringRef getArgument() const override { return "boas-to-linalg"; }

  ::llvm::StringRef getDescription() const override { return "Lower Boas matrix operations to Linalg"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BoasToLinalgLoweringPass");
  }
  ::llvm::StringRef getName() const override { return "BoasToLinalgLoweringPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<linalg::LinalgDialect>();
    registry.insert<tensor::TensorDialect>();
    registry.insert<arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BoasToLinalgLoweringPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class BoasToStandardLoweringPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BoasToStandardLoweringPassBase;

  BoasToStandardLoweringPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BoasToStandardLoweringPassBase(const BoasToStandardLoweringPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  BoasToStandardLoweringPassBase& operator=(const BoasToStandardLoweringPassBase &) = delete;
  BoasToStandardLoweringPassBase(BoasToStandardLoweringPassBase &&) = delete;
  BoasToStandardLoweringPassBase& operator=(BoasToStandardLoweringPassBase &&) = delete;
  ~BoasToStandardLoweringPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("boas-to-standard");
  }
  ::llvm::StringRef getArgument() const override { return "boas-to-standard"; }

  ::llvm::StringRef getDescription() const override { return "Lower Boas dialect to standard dialects"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BoasToStandardLoweringPass");
  }
  ::llvm::StringRef getName() const override { return "BoasToStandardLoweringPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BoasToStandardLoweringPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DeviceAwareOptimizationPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = DeviceAwareOptimizationPassBase;

  DeviceAwareOptimizationPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  DeviceAwareOptimizationPassBase(const DeviceAwareOptimizationPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  DeviceAwareOptimizationPassBase& operator=(const DeviceAwareOptimizationPassBase &) = delete;
  DeviceAwareOptimizationPassBase(DeviceAwareOptimizationPassBase &&) = delete;
  DeviceAwareOptimizationPassBase& operator=(DeviceAwareOptimizationPassBase &&) = delete;
  ~DeviceAwareOptimizationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("boas-device-opt");
  }
  ::llvm::StringRef getArgument() const override { return "boas-device-opt"; }

  ::llvm::StringRef getDescription() const override { return "Device-aware optimization for Boas operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DeviceAwareOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "DeviceAwareOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DeviceAwareOptimizationPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<std::string> availableDevices{*this, "available-devices", ::llvm::cl::desc("List of available devices"), llvm::cl::MiscFlags::CommaSeparated};
  ::mlir::Pass::Option<bool> enableAutoPlacement{*this, "enable-auto-placement", ::llvm::cl::desc("Enable automatic device placement"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class NPUKernelGenerationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = NPUKernelGenerationPassBase;

  NPUKernelGenerationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  NPUKernelGenerationPassBase(const NPUKernelGenerationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  NPUKernelGenerationPassBase& operator=(const NPUKernelGenerationPassBase &) = delete;
  NPUKernelGenerationPassBase(NPUKernelGenerationPassBase &&) = delete;
  NPUKernelGenerationPassBase& operator=(NPUKernelGenerationPassBase &&) = delete;
  ~NPUKernelGenerationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("npu-kernel-gen");
  }
  ::llvm::StringRef getArgument() const override { return "npu-kernel-gen"; }

  ::llvm::StringRef getDescription() const override { return "Generate NPU kernels for Boas operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NPUKernelGenerationPass");
  }
  ::llvm::StringRef getName() const override { return "NPUKernelGenerationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NPUKernelGenerationPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> kernelNamePrefix{*this, "kernel-prefix", ::llvm::cl::desc("Prefix for generated kernel names"), ::llvm::cl::init("boas_")};
  ::mlir::Pass::Option<bool> generateDebugInfo{*this, "debug-info", ::llvm::cl::desc("Generate debug information for kernels"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> optimizeKernelLaunch{*this, "optimize-launch", ::llvm::cl::desc("Optimize kernel launch overhead"), ::llvm::cl::init(true)};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
